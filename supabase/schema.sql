
-- Расширение для UUID и crypt
create extension if not exists pgcrypto;

-- Таблица сообщений (мягкое удаление + изображения)
create table if not exists public.messages (
  id uuid primary key default gen_random_uuid(),
  content text,
  image_url text,
  role text check (role in ('user','admin')),
  created_at timestamptz not null default now(),
  deleted_at timestamptz
);

-- Включаем RLS
alter table public.messages enable row level security;

-- Политики: анонимному роли (anon) разрешены чтение, вставка и обновление (мягкое удаление)
create policy if not exists "Anon can read messages" on public.messages
  for select to anon using (true);

create policy if not exists "Anon can insert messages" on public.messages
  for insert to anon with check (true);

create policy if not exists "Anon can update messages" on public.messages
  for update to anon using (true) with check (true);

-- Публичный бакет для изображений
select storage.create_bucket('chat-media', public := true)
where not exists (select 1 from storage.buckets where id = 'chat-media');

create policy if not exists "Anon can read chat-media" on storage.objects
  for select to anon using (bucket_id = 'chat-media');

create policy if not exists "Anon can upload chat-media" on storage.objects
  for insert to anon with check (bucket_id = 'chat-media');

create policy if not exists "Anon can update chat-media" on storage.objects
  for update to anon using (bucket_id = 'chat-media') with check (bucket_id = 'chat-media');

-- Таблица секретов (bcrypt‑хэши паролей), без публичного доступа
create table if not exists public.secrets (
  id bigint generated by default as identity primary key,
  role text check (role in ('user','admin')) not null,
  hash text not null
);

alter table public.secrets enable row level security;

-- Явно запрещаем анониму читать/менять секреты
create policy if not exists "Anon cannot select secrets" on public.secrets
  for select to anon using (false);
create policy if not exists "Anon cannot modify secrets" on public.secrets
  for all to anon using (false) with check (false);

-- Функция проверки пароля (SECURITY DEFINER): возвращает роль при совпадении хэша
create or replace function public.check_password(p_password text)
returns text
language plpgsql
security definer
set search_path = public
as $$
declare r text;
begin
  select s.role into r
  from public.secrets s
  where crypt(p_password, s.hash) = s.hash
  limit 1;
  return r; -- null, если не найдено
end;
$$;

-- Разрешаем анониму вызывать RPC (только функцию, без доступа к таблице)
grant execute on function public.check_password(text) to anon;

-- Пароли добавьте сами:
-- insert into public.secrets(role, hash)
-- values
--   ('user', crypt('userpass', gen_salt('bf'))),
--   ('admin', crypt('adminpass', gen_salt('bf')));
